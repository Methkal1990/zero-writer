-- ZeroWriter Supabase schema (v1)
-- Safe to re-run; uses IF NOT EXISTS where possible

-- 1) Required extension for gen_random_uuid()
create schema if not exists extensions;
create extension if not exists pgcrypto with schema extensions;

-- 2) Projects table
create table if not exists public.projects (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  kind text not null check (kind = 'fiction'),
  title text,
  description text,
  plot text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_projects_user on public.projects(user_id);

alter table public.projects enable row level security;

-- Policies
create policy if not exists "projects_select_owner"
  on public.projects for select
  using (auth.uid() = user_id);

create policy if not exists "projects_insert_owner"
  on public.projects for insert
  with check (auth.uid() = user_id);

create policy if not exists "projects_update_owner"
  on public.projects for update
  using (auth.uid() = user_id);

create policy if not exists "projects_delete_owner"
  on public.projects for delete
  using (auth.uid() = user_id);

-- 3) Chapters table
create table if not exists public.chapters (
  id uuid primary key default gen_random_uuid(),
  project_id uuid not null references public.projects(id) on delete cascade,
  index int generated by default as identity,
  title text,
  content text,
  created_at timestamptz not null default now()
);

create index if not exists idx_chapters_project on public.chapters(project_id);
create index if not exists idx_chapters_order on public.chapters(index);

alter table public.chapters enable row level security;

create policy if not exists "chapters_select_owner"
  on public.chapters for select
  using (exists (
    select 1 from public.projects p where p.id = chapters.project_id and p.user_id = auth.uid()
  ));

create policy if not exists "chapters_write_owner"
  on public.chapters for all
  using (exists (
    select 1 from public.projects p where p.id = chapters.project_id and p.user_id = auth.uid()
  ));

-- 4) Project hierarchical nodes (folders/files/chapters)
create table if not exists public.project_nodes (
  id uuid primary key default gen_random_uuid(),
  project_id uuid not null references public.projects(id) on delete cascade,
  parent_id uuid references public.project_nodes(id) on delete cascade,
  kind text not null check (kind in ('folder','file','chapter')),
  name text not null,
  chapter_id uuid references public.chapters(id) on delete set null,
  content text, -- Content for files (folders and chapters use other tables)
  position int generated by default as identity,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_nodes_project on public.project_nodes(project_id);
create index if not exists idx_nodes_parent on public.project_nodes(parent_id);

alter table public.project_nodes enable row level security;

create policy if not exists "nodes_select_owner"
  on public.project_nodes for select
  using (exists (select 1 from public.projects p where p.id = project_nodes.project_id and p.user_id = auth.uid()));

create policy if not exists "nodes_write_owner"
  on public.project_nodes for all
  using (exists (select 1 from public.projects p where p.id = project_nodes.project_id and p.user_id = auth.uid()));

-- 5) Add updated_at column to existing projects table (safe migration)
alter table public.projects add column if not exists updated_at timestamptz not null default now();

-- 6) Function and triggers for updated_at timestamps
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Drop triggers if they exist and recreate them
drop trigger if exists update_projects_updated_at on public.projects;
create trigger update_projects_updated_at
  before update on public.projects
  for each row execute function update_updated_at_column();

drop trigger if exists update_nodes_updated_at on public.project_nodes;
create trigger update_nodes_updated_at
  before update on public.project_nodes
  for each row execute function update_updated_at_column();
